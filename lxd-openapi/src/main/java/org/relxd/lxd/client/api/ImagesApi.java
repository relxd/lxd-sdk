/*
 * LXD
 * The services listed below are referred as .....
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@relxd.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.relxd.lxd.client.api;

import org.relxd.lxd.client.ApiClient;
import org.relxd.lxd.client.ApiException;
import org.relxd.lxd.client.ApiResponse;
import org.relxd.lxd.client.Pair;

import org.relxd.lxd.client.model.BackgroundOperationResponse;
import org.relxd.lxd.client.model.CreateImagesAliasesByNameRequest;
import org.relxd.lxd.client.model.CreateImagesAliasesRequest;
import org.relxd.lxd.client.model.CreateImagesFingerprintExportRequest;
import org.relxd.lxd.client.model.CreateImagesRequest;
import org.relxd.lxd.client.model.ErrorResponse;
import org.relxd.lxd.client.model.PatchImagesFingerprintRequest;
import org.relxd.lxd.client.model.UpdateImagesAliasesByNameRequest;
import org.relxd.lxd.client.model.UpdateImagesFingerprintRequest;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.function.Consumer;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;

import java.util.concurrent.CompletableFuture;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ImagesApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public ImagesApi() {
    this(new ApiClient());
  }

  public ImagesApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  private ApiException getApiException(String operationId, HttpResponse<String> response) {
    String message = formatExceptionMessage(operationId, response.statusCode(), response.body());
    return new ApiException(response.statusCode(), message, response.headers(), response.body());
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * 
   * Remove an alias
   * @param name Name of the alias (required)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> deleteImagesAliasesByName(String name) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteImagesAliasesByNameRequestBuilder(name);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteImagesAliasesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Remove an alias
   * @param name Name of the alias (required)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> deleteImagesAliasesByNameWithHttpInfo(String name) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteImagesAliasesByNameRequestBuilder(name);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteImagesAliasesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder deleteImagesAliasesByNameRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling deleteImagesAliasesByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/aliases/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Remove an image
   * @param fingerprint Unique fingerprint (required)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> deleteImagesFingerprint(String fingerprint) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteImagesFingerprintRequestBuilder(fingerprint);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteImagesFingerprint", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Remove an image
   * @param fingerprint Unique fingerprint (required)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> deleteImagesFingerprintWithHttpInfo(String fingerprint) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteImagesFingerprintRequestBuilder(fingerprint);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteImagesFingerprint", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder deleteImagesFingerprintRequestBuilder(String fingerprint) throws ApiException {
    // verify the required parameter 'fingerprint' is set
    if (fingerprint == null) {
      throw new ApiException(400, "Missing the required parameter 'fingerprint' when calling deleteImagesFingerprint");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/{fingerprint}"
        .replace("{fingerprint}", ApiClient.urlEncode(fingerprint.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * List of images (public or private)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getImages(Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesRequestBuilder(recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImages", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * List of images (public or private)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getImagesWithHttpInfo(Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesRequestBuilder(recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImages", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getImagesRequestBuilder(Integer recursion, String filter) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * List of aliases (public or private based on image visibility)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getImagesAliases(Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesAliasesRequestBuilder(recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImagesAliases", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * List of aliases (public or private based on image visibility)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getImagesAliasesWithHttpInfo(Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesAliasesRequestBuilder(recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImagesAliases", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getImagesAliasesRequestBuilder(Integer recursion, String filter) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/aliases";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Alias description and target
   * @param name Name of the alias (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getImagesAliasesByName(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesAliasesByNameRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImagesAliasesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Alias description and target
   * @param name Name of the alias (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getImagesAliasesByNameWithHttpInfo(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesAliasesByNameRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImagesAliasesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getImagesAliasesByNameRequestBuilder(String name, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getImagesAliasesByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/aliases/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Download the image tarball
   * @param fingerprint Unique fingerprint (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @param secret secret (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getImagesByFingerprintExport(String fingerprint, Integer recursion, String filter, String secret) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesByFingerprintExportRequestBuilder(fingerprint, recursion, filter, secret);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImagesByFingerprintExport", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Download the image tarball
   * @param fingerprint Unique fingerprint (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @param secret secret (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getImagesByFingerprintExportWithHttpInfo(String fingerprint, Integer recursion, String filter, String secret) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesByFingerprintExportRequestBuilder(fingerprint, recursion, filter, secret);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImagesByFingerprintExport", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getImagesByFingerprintExportRequestBuilder(String fingerprint, Integer recursion, String filter, String secret) throws ApiException {
    // verify the required parameter 'fingerprint' is set
    if (fingerprint == null) {
      throw new ApiException(400, "Missing the required parameter 'fingerprint' when calling getImagesByFingerprintExport");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/{fingerprint}/export"
        .replace("{fingerprint}", ApiClient.urlEncode(fingerprint.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("secret", secret));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Image description and metadata
   * @param fingerprint Unique fingerprint (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @param secret secret (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getImagesFingerprint(String fingerprint, Integer recursion, String filter, String secret) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesFingerprintRequestBuilder(fingerprint, recursion, filter, secret);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImagesFingerprint", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Image description and metadata
   * @param fingerprint Unique fingerprint (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @param secret secret (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getImagesFingerprintWithHttpInfo(String fingerprint, Integer recursion, String filter, String secret) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesFingerprintRequestBuilder(fingerprint, recursion, filter, secret);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImagesFingerprint", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getImagesFingerprintRequestBuilder(String fingerprint, Integer recursion, String filter, String secret) throws ApiException {
    // verify the required parameter 'fingerprint' is set
    if (fingerprint == null) {
      throw new ApiException(400, "Missing the required parameter 'fingerprint' when calling getImagesFingerprint");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/{fingerprint}"
        .replace("{fingerprint}", ApiClient.urlEncode(fingerprint.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("secret", secret));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Refresh an image from its origin
   * @param fingerprint Unique fingerprint (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getImagesFingerprintRefresh(String fingerprint, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesFingerprintRefreshRequestBuilder(fingerprint, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImagesFingerprintRefresh", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Refresh an image from its origin
   * @param fingerprint Unique fingerprint (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getImagesFingerprintRefreshWithHttpInfo(String fingerprint, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getImagesFingerprintRefreshRequestBuilder(fingerprint, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getImagesFingerprintRefresh", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getImagesFingerprintRefreshRequestBuilder(String fingerprint, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'fingerprint' is set
    if (fingerprint == null) {
      throw new ApiException(400, "Missing the required parameter 'fingerprint' when calling getImagesFingerprintRefresh");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/{fingerprint}/refresh"
        .replace("{fingerprint}", ApiClient.urlEncode(fingerprint.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Updates the alias target or description
   * @param name Name of the alias (required)
   * @param body Updates the alias target or description (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> patchImagesAliasesByName(String name, UpdateImagesAliasesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = patchImagesAliasesByNameRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("patchImagesAliasesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Updates the alias target or description
   * @param name Name of the alias (required)
   * @param body Updates the alias target or description (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> patchImagesAliasesByNameWithHttpInfo(String name, UpdateImagesAliasesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = patchImagesAliasesByNameRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("patchImagesAliasesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder patchImagesAliasesByNameRequestBuilder(String name, UpdateImagesAliasesByNameRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling patchImagesAliasesByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/aliases/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PATCH", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Updates the image properties, update information and visibility
   * @param fingerprint Unique fingerprint (required)
   * @param body Updates the image properties, update information and visibility (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> patchImagesFingerprint(String fingerprint, PatchImagesFingerprintRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = patchImagesFingerprintRequestBuilder(fingerprint, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("patchImagesFingerprint", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Updates the image properties, update information and visibility
   * @param fingerprint Unique fingerprint (required)
   * @param body Updates the image properties, update information and visibility (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> patchImagesFingerprintWithHttpInfo(String fingerprint, PatchImagesFingerprintRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = patchImagesFingerprintRequestBuilder(fingerprint, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("patchImagesFingerprint", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder patchImagesFingerprintRequestBuilder(String fingerprint, PatchImagesFingerprintRequest body) throws ApiException {
    // verify the required parameter 'fingerprint' is set
    if (fingerprint == null) {
      throw new ApiException(400, "Missing the required parameter 'fingerprint' when calling patchImagesFingerprint");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/{fingerprint}"
        .replace("{fingerprint}", ApiClient.urlEncode(fingerprint.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PATCH", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Create and publish a new image
   * @param xLXDFingerprint if set, uploaded file must match (optional)
   * @param xLXDFilename used for export (optional)
   * @param xLXDPublic defaults to false (optional)
   * @param xLXDProperties  (optional)
   * @param body Create and publish a new image (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postImages(String xLXDFingerprint, String xLXDFilename, Boolean xLXDPublic, String xLXDProperties, CreateImagesRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postImagesRequestBuilder(xLXDFingerprint, xLXDFilename, xLXDPublic, xLXDProperties, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postImages", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Create and publish a new image
   * @param xLXDFingerprint if set, uploaded file must match (optional)
   * @param xLXDFilename used for export (optional)
   * @param xLXDPublic defaults to false (optional)
   * @param xLXDProperties  (optional)
   * @param body Create and publish a new image (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postImagesWithHttpInfo(String xLXDFingerprint, String xLXDFilename, Boolean xLXDPublic, String xLXDProperties, CreateImagesRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postImagesRequestBuilder(xLXDFingerprint, xLXDFilename, xLXDPublic, xLXDProperties, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postImages", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postImagesRequestBuilder(String xLXDFingerprint, String xLXDFilename, Boolean xLXDPublic, String xLXDProperties, CreateImagesRequest body) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("X-LXD-fingerprint", xLXDFingerprint));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (xLXDFilename != null) {
      localVarRequestBuilder.header("X-LXD-filename", xLXDFilename.toString());
    }
    if (xLXDPublic != null) {
      localVarRequestBuilder.header("X-LXD-public", xLXDPublic.toString());
    }
    if (xLXDProperties != null) {
      localVarRequestBuilder.header("X-LXD-properties", xLXDProperties.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Create a new alias
   * @param body Create a new alias (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postImagesAliases(CreateImagesAliasesRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postImagesAliasesRequestBuilder(body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postImagesAliases", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Create a new alias
   * @param body Create a new alias (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postImagesAliasesWithHttpInfo(CreateImagesAliasesRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postImagesAliasesRequestBuilder(body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postImagesAliases", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postImagesAliasesRequestBuilder(CreateImagesAliasesRequest body) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/aliases";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Rename an alias
   * @param name Name of the alias (required)
   * @param body Rename an alias (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postImagesAliasesByName(String name, CreateImagesAliasesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postImagesAliasesByNameRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postImagesAliasesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Rename an alias
   * @param name Name of the alias (required)
   * @param body Rename an alias (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postImagesAliasesByNameWithHttpInfo(String name, CreateImagesAliasesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postImagesAliasesByNameRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postImagesAliasesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postImagesAliasesByNameRequestBuilder(String name, CreateImagesAliasesByNameRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postImagesAliasesByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/aliases/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Upload the image tarball
   * @param fingerprint Unique fingerprint (required)
   * @param body Upload the image tarball (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postImagesFingerprintExport(String fingerprint, CreateImagesFingerprintExportRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postImagesFingerprintExportRequestBuilder(fingerprint, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postImagesFingerprintExport", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Upload the image tarball
   * @param fingerprint Unique fingerprint (required)
   * @param body Upload the image tarball (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postImagesFingerprintExportWithHttpInfo(String fingerprint, CreateImagesFingerprintExportRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postImagesFingerprintExportRequestBuilder(fingerprint, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postImagesFingerprintExport", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postImagesFingerprintExportRequestBuilder(String fingerprint, CreateImagesFingerprintExportRequest body) throws ApiException {
    // verify the required parameter 'fingerprint' is set
    if (fingerprint == null) {
      throw new ApiException(400, "Missing the required parameter 'fingerprint' when calling postImagesFingerprintExport");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/{fingerprint}/export"
        .replace("{fingerprint}", ApiClient.urlEncode(fingerprint.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Generate a random token and tell LXD to expect it be used by a guest
   * @param fingerprint Unique fingerprint (required)
   * @param body Generate a random token and tell LXD to expect it be used by a guest (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postImagesFingerprintSecret(String fingerprint, Object body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postImagesFingerprintSecretRequestBuilder(fingerprint, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postImagesFingerprintSecret", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Generate a random token and tell LXD to expect it be used by a guest
   * @param fingerprint Unique fingerprint (required)
   * @param body Generate a random token and tell LXD to expect it be used by a guest (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postImagesFingerprintSecretWithHttpInfo(String fingerprint, Object body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postImagesFingerprintSecretRequestBuilder(fingerprint, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postImagesFingerprintSecret", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postImagesFingerprintSecretRequestBuilder(String fingerprint, Object body) throws ApiException {
    // verify the required parameter 'fingerprint' is set
    if (fingerprint == null) {
      throw new ApiException(400, "Missing the required parameter 'fingerprint' when calling postImagesFingerprintSecret");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/{fingerprint}/secret"
        .replace("{fingerprint}", ApiClient.urlEncode(fingerprint.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Replaces the alias target or description
   * @param name Name of the alias (required)
   * @param body Replaces the alias target or description (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> putImagesAliasesByName(String name, UpdateImagesAliasesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putImagesAliasesByNameRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putImagesAliasesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Replaces the alias target or description
   * @param name Name of the alias (required)
   * @param body Replaces the alias target or description (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> putImagesAliasesByNameWithHttpInfo(String name, UpdateImagesAliasesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putImagesAliasesByNameRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putImagesAliasesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder putImagesAliasesByNameRequestBuilder(String name, UpdateImagesAliasesByNameRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling putImagesAliasesByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/aliases/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Replaces the image properties, update information and visibility
   * @param fingerprint Unique fingerprint (required)
   * @param body Replaces the image properties, update information and visibility (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> putImagesFingerprint(String fingerprint, UpdateImagesFingerprintRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putImagesFingerprintRequestBuilder(fingerprint, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putImagesFingerprint", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Replaces the image properties, update information and visibility
   * @param fingerprint Unique fingerprint (required)
   * @param body Replaces the image properties, update information and visibility (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> putImagesFingerprintWithHttpInfo(String fingerprint, UpdateImagesFingerprintRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putImagesFingerprintRequestBuilder(fingerprint, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putImagesFingerprint", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder putImagesFingerprintRequestBuilder(String fingerprint, UpdateImagesFingerprintRequest body) throws ApiException {
    // verify the required parameter 'fingerprint' is set
    if (fingerprint == null) {
      throw new ApiException(400, "Missing the required parameter 'fingerprint' when calling putImagesFingerprint");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/images/{fingerprint}"
        .replace("{fingerprint}", ApiClient.urlEncode(fingerprint.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
