/*
 * LXD
 * The services listed below are referred as .....
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@relxd.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.relxd.lxd.client.api;

import org.relxd.lxd.client.ApiClient;
import org.relxd.lxd.client.ApiException;
import org.relxd.lxd.client.ApiResponse;
import org.relxd.lxd.client.Pair;

import org.relxd.lxd.client.model.BackgroundOperationResponse;
import org.relxd.lxd.client.model.CreateInstancesByNameBackupsByNameRequest;
import org.relxd.lxd.client.model.CreateInstancesByNameBackupsRequest;
import org.relxd.lxd.client.model.CreateInstancesByNameConsoleRequest;
import org.relxd.lxd.client.model.CreateInstancesByNameExecRequest;
import org.relxd.lxd.client.model.CreateInstancesByNameRequest;
import org.relxd.lxd.client.model.CreateInstancesByNameSnapshotRequest;
import org.relxd.lxd.client.model.CreateInstancesByNameSnapshotsInformationRequest;
import org.relxd.lxd.client.model.CreateInstancesRequest;
import org.relxd.lxd.client.model.ErrorResponse;
import java.io.File;
import org.relxd.lxd.client.model.GetInstancesByNameMetadataResponse;
import org.relxd.lxd.client.model.PatchInstancesByNameRequest;
import org.relxd.lxd.client.model.RawFile;
import java.util.UUID;
import org.relxd.lxd.client.model.UpdateInstancesByNameRequest;
import org.relxd.lxd.client.model.UpdateInstancesByNameSnapshotsInformationRequest;
import org.relxd.lxd.client.model.UpdateInstancesByNameStateRequest;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.function.Consumer;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;

import java.util.concurrent.CompletableFuture;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class InstancesApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public InstancesApi() {
    this(new ApiClient());
  }

  public InstancesApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  private ApiException getApiException(String operationId, HttpResponse<String> response) {
    String message = formatExceptionMessage(operationId, response.statusCode(), response.body());
    return new ApiException(response.statusCode(), message, response.headers(), response.body());
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * 
   * Remove the instance
   * @param name Instance name (required)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> deleteInstancesByName(String name) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameRequestBuilder(name);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Remove the instance
   * @param name Instance name (required)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> deleteInstancesByNameWithHttpInfo(String name) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameRequestBuilder(name);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder deleteInstancesByNameRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling deleteInstancesByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Remove the backup
   * @param name Instance name (required)
   * @param backupsName Backups name (required)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> deleteInstancesByNameBackupsByName(String name, String backupsName) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameBackupsByNameRequestBuilder(name, backupsName);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameBackupsByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Remove the backup
   * @param name Instance name (required)
   * @param backupsName Backups name (required)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> deleteInstancesByNameBackupsByNameWithHttpInfo(String name, String backupsName) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameBackupsByNameRequestBuilder(name, backupsName);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameBackupsByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder deleteInstancesByNameBackupsByNameRequestBuilder(String name, String backupsName) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling deleteInstancesByNameBackupsByName");
    }
    // verify the required parameter 'backupsName' is set
    if (backupsName == null) {
      throw new ApiException(400, "Missing the required parameter 'backupsName' when calling deleteInstancesByNameBackupsByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/backups/{backupsName}"
        .replace("{name}", ApiClient.urlEncode(name.toString()))
        .replace("{backupsName}", ApiClient.urlEncode(backupsName.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Empty the instance&#39;s console log
   * @param name Instance name (required)
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Void> deleteInstancesByNameConsole(String name) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameConsoleRequestBuilder(name);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameConsole", localVarResponse));
            }
            return CompletableFuture.completedFuture(null);
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Empty the instance&#39;s console log
   * @param name Instance name (required)
   * @return CompletableFuture&lt;ApiResponse&lt;Void&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Void>> deleteInstancesByNameConsoleWithHttpInfo(String name) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameConsoleRequestBuilder(name);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameConsole", localVarResponse));
            }
            return CompletableFuture.completedFuture(
                new ApiResponse<Void>(localVarResponse.statusCode(), localVarResponse.headers().map(), null)
            );
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder deleteInstancesByNameConsoleRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling deleteInstancesByNameConsole");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/console"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Delete a file in the instance
   * @param name Instance name (required)
   * @param path directory listing from the instance (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> deleteInstancesByNameFiles(String name, String path) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameFilesRequestBuilder(name, path);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameFiles", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Delete a file in the instance
   * @param name Instance name (required)
   * @param path directory listing from the instance (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> deleteInstancesByNameFilesWithHttpInfo(String name, String path) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameFilesRequestBuilder(name, path);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameFiles", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder deleteInstancesByNameFilesRequestBuilder(String name, String path) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling deleteInstancesByNameFiles");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/files"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("path", path));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Delete a particular log file.
   * @param name Instance name (required)
   * @param logFile Instance log file (required)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> deleteInstancesByNameLogsFile(String name, String logFile) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameLogsFileRequestBuilder(name, logFile);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameLogsFile", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Delete a particular log file.
   * @param name Instance name (required)
   * @param logFile Instance log file (required)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> deleteInstancesByNameLogsFileWithHttpInfo(String name, String logFile) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameLogsFileRequestBuilder(name, logFile);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameLogsFile", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder deleteInstancesByNameLogsFileRequestBuilder(String name, String logFile) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling deleteInstancesByNameLogsFile");
    }
    // verify the required parameter 'logFile' is set
    if (logFile == null) {
      throw new ApiException(400, "Missing the required parameter 'logFile' when calling deleteInstancesByNameLogsFile");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/logs/{logFile}"
        .replace("{name}", ApiClient.urlEncode(name.toString()))
        .replace("{logFile}", ApiClient.urlEncode(logFile.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Delete an instance template
   * @param name Instance name (required)
   * @param path Template (required)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> deleteInstancesByNameMetadataTemplates(String name, String path) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameMetadataTemplatesRequestBuilder(name, path);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameMetadataTemplates", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Delete an instance template
   * @param name Instance name (required)
   * @param path Template (required)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> deleteInstancesByNameMetadataTemplatesWithHttpInfo(String name, String path) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameMetadataTemplatesRequestBuilder(name, path);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameMetadataTemplates", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder deleteInstancesByNameMetadataTemplatesRequestBuilder(String name, String path) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling deleteInstancesByNameMetadataTemplates");
    }
    // verify the required parameter 'path' is set
    if (path == null) {
      throw new ApiException(400, "Missing the required parameter 'path' when calling deleteInstancesByNameMetadataTemplates");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/metadata/templates"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("path", path));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Remove the snapshot
   * @param name Instance name (required)
   * @param snapshotName Snapshot name (required)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> deleteInstancesByNameSnapshotsInformation(String name, String snapshotName) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameSnapshotsInformationRequestBuilder(name, snapshotName);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameSnapshotsInformation", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Remove the snapshot
   * @param name Instance name (required)
   * @param snapshotName Snapshot name (required)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> deleteInstancesByNameSnapshotsInformationWithHttpInfo(String name, String snapshotName) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = deleteInstancesByNameSnapshotsInformationRequestBuilder(name, snapshotName);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("deleteInstancesByNameSnapshotsInformation", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder deleteInstancesByNameSnapshotsInformationRequestBuilder(String name, String snapshotName) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling deleteInstancesByNameSnapshotsInformation");
    }
    // verify the required parameter 'snapshotName' is set
    if (snapshotName == null) {
      throw new ApiException(400, "Missing the required parameter 'snapshotName' when calling deleteInstancesByNameSnapshotsInformation");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/snapshots/{snapshotName}"
        .replace("{name}", ApiClient.urlEncode(name.toString()))
        .replace("{snapshotName}", ApiClient.urlEncode(snapshotName.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Return a list of URLs for instances this server hosts
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstances(Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesRequestBuilder(recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstances", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Return a list of URLs for instances this server hosts
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesWithHttpInfo(Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesRequestBuilder(recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstances", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesRequestBuilder(Integer recursion, String filter) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Get Instance information
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByName(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Get Instance information
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameWithHttpInfo(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameRequestBuilder(String name, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * List of backups for the instance
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameBackups(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameBackupsRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameBackups", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * List of backups for the instance
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameBackupsWithHttpInfo(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameBackupsRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameBackups", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameBackupsRequestBuilder(String name, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameBackups");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/backups"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Backup information
   * @param name Instance name (required)
   * @param backupsName Backups name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameBackupsByName(String name, String backupsName, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameBackupsByNameRequestBuilder(name, backupsName, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameBackupsByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Backup information
   * @param name Instance name (required)
   * @param backupsName Backups name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameBackupsByNameWithHttpInfo(String name, String backupsName, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameBackupsByNameRequestBuilder(name, backupsName, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameBackupsByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameBackupsByNameRequestBuilder(String name, String backupsName, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameBackupsByName");
    }
    // verify the required parameter 'backupsName' is set
    if (backupsName == null) {
      throw new ApiException(400, "Missing the required parameter 'backupsName' when calling getInstancesByNameBackupsByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/backups/{backupsName}"
        .replace("{name}", ApiClient.urlEncode(name.toString()))
        .replace("{backupsName}", ApiClient.urlEncode(backupsName.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Fetch the backup tarball
   * @param name Instance name (required)
   * @param backupsName Backups name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameBackupsByNameExport(String name, String backupsName, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameBackupsByNameExportRequestBuilder(name, backupsName, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameBackupsByNameExport", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Fetch the backup tarball
   * @param name Instance name (required)
   * @param backupsName Backups name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameBackupsByNameExportWithHttpInfo(String name, String backupsName, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameBackupsByNameExportRequestBuilder(name, backupsName, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameBackupsByNameExport", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameBackupsByNameExportRequestBuilder(String name, String backupsName, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameBackupsByNameExport");
    }
    // verify the required parameter 'backupsName' is set
    if (backupsName == null) {
      throw new ApiException(400, "Missing the required parameter 'backupsName' when calling getInstancesByNameBackupsByNameExport");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/backups/{backupsName}/export"
        .replace("{name}", ApiClient.urlEncode(name.toString()))
        .replace("{backupsName}", ApiClient.urlEncode(backupsName.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Returns the contents of the instance&#39;s console log
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameConsole(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameConsoleRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameConsole", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Returns the contents of the instance&#39;s console log
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameConsoleWithHttpInfo(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameConsoleRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameConsole", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameConsoleRequestBuilder(String name, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameConsole");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/console"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Download a file or directory listing from the instance
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @param path directory listing from the instance (optional)
   * @param xLXDUid  (optional)
   * @param xLXDGid  (optional)
   * @param xLXDMode  (optional)
   * @param xLXDType one of directory or file (optional)
   * @return CompletableFuture&lt;RawFile&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<RawFile> getInstancesByNameFiles(String name, Integer recursion, String filter, String path, Integer xLXDUid, Integer xLXDGid, Integer xLXDMode, UUID xLXDType) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameFilesRequestBuilder(name, recursion, filter, path, xLXDUid, xLXDGid, xLXDMode, xLXDType);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameFiles", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<RawFile>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Download a file or directory listing from the instance
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @param path directory listing from the instance (optional)
   * @param xLXDUid  (optional)
   * @param xLXDGid  (optional)
   * @param xLXDMode  (optional)
   * @param xLXDType one of directory or file (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;RawFile&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<RawFile>> getInstancesByNameFilesWithHttpInfo(String name, Integer recursion, String filter, String path, Integer xLXDUid, Integer xLXDGid, Integer xLXDMode, UUID xLXDType) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameFilesRequestBuilder(name, recursion, filter, path, xLXDUid, xLXDGid, xLXDMode, xLXDType);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameFiles", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<RawFile>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<RawFile>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameFilesRequestBuilder(String name, Integer recursion, String filter, String path, Integer xLXDUid, Integer xLXDGid, Integer xLXDMode, UUID xLXDType) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameFiles");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/files"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("path", path));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (xLXDUid != null) {
      localVarRequestBuilder.header("X-LXD-uid", xLXDUid.toString());
    }
    if (xLXDGid != null) {
      localVarRequestBuilder.header("X-LXD-gid", xLXDGid.toString());
    }
    if (xLXDMode != null) {
      localVarRequestBuilder.header("X-LXD-mode", xLXDMode.toString());
    }
    if (xLXDType != null) {
      localVarRequestBuilder.header("X-LXD-type", xLXDType.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Returns a list of the log files available for this instance. Note that this works on instances that have been deleted (or were never created) to enable people to get logs for failed creations.
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameLogs(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameLogsRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameLogs", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Returns a list of the log files available for this instance. Note that this works on instances that have been deleted (or were never created) to enable people to get logs for failed creations.
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameLogsWithHttpInfo(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameLogsRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameLogs", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameLogsRequestBuilder(String name, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameLogs");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/logs"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Returns the contents of a particular log file.
   * @param name Instance name (required)
   * @param logFile Instance log file (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameLogsFile(String name, String logFile, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameLogsFileRequestBuilder(name, logFile, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameLogsFile", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Returns the contents of a particular log file.
   * @param name Instance name (required)
   * @param logFile Instance log file (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameLogsFileWithHttpInfo(String name, String logFile, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameLogsFileRequestBuilder(name, logFile, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameLogsFile", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameLogsFileRequestBuilder(String name, String logFile, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameLogsFile");
    }
    // verify the required parameter 'logFile' is set
    if (logFile == null) {
      throw new ApiException(400, "Missing the required parameter 'logFile' when calling getInstancesByNameLogsFile");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/logs/{logFile}"
        .replace("{name}", ApiClient.urlEncode(name.toString()))
        .replace("{logFile}", ApiClient.urlEncode(logFile.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Instance metadata
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameMetadata(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameMetadataRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameMetadata", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Instance metadata
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameMetadataWithHttpInfo(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameMetadataRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameMetadata", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameMetadataRequestBuilder(String name, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameMetadata");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/metadata"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * List instance templates
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @param path Template (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameMetadataTemplates(String name, Integer recursion, String filter, String path) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameMetadataTemplatesRequestBuilder(name, recursion, filter, path);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameMetadataTemplates", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * List instance templates
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @param path Template (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameMetadataTemplatesWithHttpInfo(String name, Integer recursion, String filter, String path) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameMetadataTemplatesRequestBuilder(name, recursion, filter, path);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameMetadataTemplates", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameMetadataTemplatesRequestBuilder(String name, Integer recursion, String filter, String path) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameMetadataTemplates");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/metadata/templates"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("path", path));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * List of snapshots
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameSnapshots(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameSnapshotsRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameSnapshots", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * List of snapshots
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameSnapshotsWithHttpInfo(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameSnapshotsRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameSnapshots", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameSnapshotsRequestBuilder(String name, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameSnapshots");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/snapshots"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Snapshot information
   * @param name Instance name (required)
   * @param snapshotName Snapshot name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameSnapshotsInformation(String name, String snapshotName, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameSnapshotsInformationRequestBuilder(name, snapshotName, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameSnapshotsInformation", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Snapshot information
   * @param name Instance name (required)
   * @param snapshotName Snapshot name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameSnapshotsInformationWithHttpInfo(String name, String snapshotName, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameSnapshotsInformationRequestBuilder(name, snapshotName, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameSnapshotsInformation", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameSnapshotsInformationRequestBuilder(String name, String snapshotName, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameSnapshotsInformation");
    }
    // verify the required parameter 'snapshotName' is set
    if (snapshotName == null) {
      throw new ApiException(400, "Missing the required parameter 'snapshotName' when calling getInstancesByNameSnapshotsInformation");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/snapshots/{snapshotName}"
        .replace("{name}", ApiClient.urlEncode(name.toString()))
        .replace("{snapshotName}", ApiClient.urlEncode(snapshotName.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Current state
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> getInstancesByNameState(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameStateRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameState", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Current state
   * @param name Instance name (required)
   * @param recursion To optimize queries of large lists, recursion is implemented for collections. The default value is 0 which means that collection member URLs are returned. Setting it to 1 will have those URLs be replaced by the object they point to (typically a dict). (optional)
   * @param filter There is no default value for filter which means that all results found will be returned. The language follows the OData conventions for structuring REST API filtering logic. Logical operators are also supported for filtering: not(not), equals(eq), not equals(ne), and(and), or(or). Filters are evaluated with left associativity. Values with spaces can be surrounded with quotes. Nesting filtering is also supported. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> getInstancesByNameStateWithHttpInfo(String name, Integer recursion, String filter) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = getInstancesByNameStateRequestBuilder(name, recursion, filter);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("getInstancesByNameState", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder getInstancesByNameStateRequestBuilder(String name, Integer recursion, String filter) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getInstancesByNameState");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/state"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recursion", recursion));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filter", filter));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Update instance configuration
   * @param name Instance name (required)
   * @param body Update instance configuration (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> patchInstancesByName(String name, PatchInstancesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = patchInstancesByNameRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("patchInstancesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Update instance configuration
   * @param name Instance name (required)
   * @param body Update instance configuration (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> patchInstancesByNameWithHttpInfo(String name, PatchInstancesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = patchInstancesByNameRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("patchInstancesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder patchInstancesByNameRequestBuilder(String name, PatchInstancesByNameRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling patchInstancesByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PATCH", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Create a new instance
   * @param target ?target&#x3D;&lt;member&gt; (optional)
   * @param body Create a new instance (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postInstances(String target, CreateInstancesRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesRequestBuilder(target, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstances", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Create a new instance
   * @param target ?target&#x3D;&lt;member&gt; (optional)
   * @param body Create a new instance (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postInstancesWithHttpInfo(String target, CreateInstancesRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesRequestBuilder(target, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstances", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postInstancesRequestBuilder(String target, CreateInstancesRequest body) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("target", target));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Used to rename/migrate the instance
   * @param name Instance name (required)
   * @param target ?target&#x3D;&lt;member&gt; (optional)
   * @param body Used to rename/migrate the instance (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postInstancesByName(String name, String target, CreateInstancesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameRequestBuilder(name, target, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Used to rename/migrate the instance
   * @param name Instance name (required)
   * @param target ?target&#x3D;&lt;member&gt; (optional)
   * @param body Used to rename/migrate the instance (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postInstancesByNameWithHttpInfo(String name, String target, CreateInstancesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameRequestBuilder(name, target, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postInstancesByNameRequestBuilder(String name, String target, CreateInstancesByNameRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postInstancesByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("target", target));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Create a new backup
   * @param name Instance name (required)
   * @param body Create a new backup (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postInstancesByNameBackups(String name, CreateInstancesByNameBackupsRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameBackupsRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameBackups", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Create a new backup
   * @param name Instance name (required)
   * @param body Create a new backup (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postInstancesByNameBackupsWithHttpInfo(String name, CreateInstancesByNameBackupsRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameBackupsRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameBackups", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postInstancesByNameBackupsRequestBuilder(String name, CreateInstancesByNameBackupsRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postInstancesByNameBackups");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/backups"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Used to rename the backup
   * @param name Instance name (required)
   * @param backupsName Backups name (required)
   * @param body Used to rename the backup (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postInstancesByNameBackupsByName(String name, String backupsName, CreateInstancesByNameBackupsByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameBackupsByNameRequestBuilder(name, backupsName, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameBackupsByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Used to rename the backup
   * @param name Instance name (required)
   * @param backupsName Backups name (required)
   * @param body Used to rename the backup (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postInstancesByNameBackupsByNameWithHttpInfo(String name, String backupsName, CreateInstancesByNameBackupsByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameBackupsByNameRequestBuilder(name, backupsName, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameBackupsByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postInstancesByNameBackupsByNameRequestBuilder(String name, String backupsName, CreateInstancesByNameBackupsByNameRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postInstancesByNameBackupsByName");
    }
    // verify the required parameter 'backupsName' is set
    if (backupsName == null) {
      throw new ApiException(400, "Missing the required parameter 'backupsName' when calling postInstancesByNameBackupsByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/backups/{backupsName}"
        .replace("{name}", ApiClient.urlEncode(name.toString()))
        .replace("{backupsName}", ApiClient.urlEncode(backupsName.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Attach to an instance&#39;s console devices
   * @param name Instance name (required)
   * @param body Attach to an instance&#39;s console devices (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postInstancesByNameConsole(String name, CreateInstancesByNameConsoleRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameConsoleRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameConsole", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Attach to an instance&#39;s console devices
   * @param name Instance name (required)
   * @param body Attach to an instance&#39;s console devices (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postInstancesByNameConsoleWithHttpInfo(String name, CreateInstancesByNameConsoleRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameConsoleRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameConsole", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postInstancesByNameConsoleRequestBuilder(String name, CreateInstancesByNameConsoleRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postInstancesByNameConsole");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/console"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Run a remote command
   * @param name Instance name (required)
   * @param body Run a remote command (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postInstancesByNameExec(String name, CreateInstancesByNameExecRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameExecRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameExec", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Run a remote command
   * @param name Instance name (required)
   * @param body Run a remote command (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postInstancesByNameExecWithHttpInfo(String name, CreateInstancesByNameExecRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameExecRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameExec", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postInstancesByNameExecRequestBuilder(String name, CreateInstancesByNameExecRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postInstancesByNameExec");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/exec"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Upload a file to the instance
   * @param name Instance name (required)
   * @param path directory listing from the instance (optional)
   * @param xLXDUid  (optional)
   * @param xLXDGid  (optional)
   * @param xLXDMode  (optional)
   * @param xLXDWrite overwrite (or append) (optional)
   * @param xLXDType one of directory or file or symlink (optional)
   * @param body Upload a file to the instance (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postInstancesByNameFiles(String name, String path, Integer xLXDUid, Integer xLXDGid, Integer xLXDMode, UUID xLXDWrite, String xLXDType, File body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameFilesRequestBuilder(name, path, xLXDUid, xLXDGid, xLXDMode, xLXDWrite, xLXDType, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameFiles", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Upload a file to the instance
   * @param name Instance name (required)
   * @param path directory listing from the instance (optional)
   * @param xLXDUid  (optional)
   * @param xLXDGid  (optional)
   * @param xLXDMode  (optional)
   * @param xLXDWrite overwrite (or append) (optional)
   * @param xLXDType one of directory or file or symlink (optional)
   * @param body Upload a file to the instance (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postInstancesByNameFilesWithHttpInfo(String name, String path, Integer xLXDUid, Integer xLXDGid, Integer xLXDMode, UUID xLXDWrite, String xLXDType, File body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameFilesRequestBuilder(name, path, xLXDUid, xLXDGid, xLXDMode, xLXDWrite, xLXDType, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameFiles", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postInstancesByNameFilesRequestBuilder(String name, String path, Integer xLXDUid, Integer xLXDGid, Integer xLXDMode, UUID xLXDWrite, String xLXDType, File body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postInstancesByNameFiles");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/files"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("path", path));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (xLXDUid != null) {
      localVarRequestBuilder.header("X-LXD-uid", xLXDUid.toString());
    }
    if (xLXDGid != null) {
      localVarRequestBuilder.header("X-LXD-gid", xLXDGid.toString());
    }
    if (xLXDMode != null) {
      localVarRequestBuilder.header("X-LXD-mode", xLXDMode.toString());
    }
    if (xLXDWrite != null) {
      localVarRequestBuilder.header("X-LXD-write", xLXDWrite.toString());
    }
    if (xLXDType != null) {
      localVarRequestBuilder.header("X-LXD-type", xLXDType.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Add a container template
   * @param name Instance name (required)
   * @param path Template (required)
   * @param body Add a container template (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postInstancesByNameMetadataTemplates(String name, String path, File body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameMetadataTemplatesRequestBuilder(name, path, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameMetadataTemplates", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Add a container template
   * @param name Instance name (required)
   * @param path Template (required)
   * @param body Add a container template (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postInstancesByNameMetadataTemplatesWithHttpInfo(String name, String path, File body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameMetadataTemplatesRequestBuilder(name, path, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameMetadataTemplates", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postInstancesByNameMetadataTemplatesRequestBuilder(String name, String path, File body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postInstancesByNameMetadataTemplates");
    }
    // verify the required parameter 'path' is set
    if (path == null) {
      throw new ApiException(400, "Missing the required parameter 'path' when calling postInstancesByNameMetadataTemplates");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/metadata/templates"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("path", path));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Create a new snapshot
   * @param name Instance name (required)
   * @param body Create a new snapshot (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postInstancesByNameSnapshot(String name, CreateInstancesByNameSnapshotRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameSnapshotRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameSnapshot", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Create a new snapshot
   * @param name Instance name (required)
   * @param body Create a new snapshot (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postInstancesByNameSnapshotWithHttpInfo(String name, CreateInstancesByNameSnapshotRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameSnapshotRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameSnapshot", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postInstancesByNameSnapshotRequestBuilder(String name, CreateInstancesByNameSnapshotRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postInstancesByNameSnapshot");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/snapshots"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Used to rename/migrate the snapshot
   * @param name Instance name (required)
   * @param snapshotName Snapshot name (required)
   * @param body Used to rename/migrate the snapshot (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> postInstancesByNameSnapshotsInformation(String name, String snapshotName, CreateInstancesByNameSnapshotsInformationRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameSnapshotsInformationRequestBuilder(name, snapshotName, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameSnapshotsInformation", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Used to rename/migrate the snapshot
   * @param name Instance name (required)
   * @param snapshotName Snapshot name (required)
   * @param body Used to rename/migrate the snapshot (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> postInstancesByNameSnapshotsInformationWithHttpInfo(String name, String snapshotName, CreateInstancesByNameSnapshotsInformationRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = postInstancesByNameSnapshotsInformationRequestBuilder(name, snapshotName, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("postInstancesByNameSnapshotsInformation", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder postInstancesByNameSnapshotsInformationRequestBuilder(String name, String snapshotName, CreateInstancesByNameSnapshotsInformationRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postInstancesByNameSnapshotsInformation");
    }
    // verify the required parameter 'snapshotName' is set
    if (snapshotName == null) {
      throw new ApiException(400, "Missing the required parameter 'snapshotName' when calling postInstancesByNameSnapshotsInformation");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/snapshots/{snapshotName}"
        .replace("{name}", ApiClient.urlEncode(name.toString()))
        .replace("{snapshotName}", ApiClient.urlEncode(snapshotName.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Replaces instance configuration or restore snapshot
   * @param name Instance name (required)
   * @param body  (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> putInstancesByName(String name, UpdateInstancesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putInstancesByNameRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putInstancesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Replaces instance configuration or restore snapshot
   * @param name Instance name (required)
   * @param body  (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> putInstancesByNameWithHttpInfo(String name, UpdateInstancesByNameRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putInstancesByNameRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putInstancesByName", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder putInstancesByNameRequestBuilder(String name, UpdateInstancesByNameRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling putInstancesByName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Replaces instance metadata
   * @param name Instance name (required)
   * @param body Replaces instance metadata (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> putInstancesByNameMetadata(String name, GetInstancesByNameMetadataResponse body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putInstancesByNameMetadataRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putInstancesByNameMetadata", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Replaces instance metadata
   * @param name Instance name (required)
   * @param body Replaces instance metadata (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> putInstancesByNameMetadataWithHttpInfo(String name, GetInstancesByNameMetadataResponse body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putInstancesByNameMetadataRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putInstancesByNameMetadata", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder putInstancesByNameMetadataRequestBuilder(String name, GetInstancesByNameMetadataResponse body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling putInstancesByNameMetadata");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/metadata"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Replace content of a template
   * @param name Instance name (required)
   * @param path Template (required)
   * @param body Replace content of a template (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> putInstancesByNameMetadataTemplates(String name, String path, File body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putInstancesByNameMetadataTemplatesRequestBuilder(name, path, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putInstancesByNameMetadataTemplates", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Replace content of a template
   * @param name Instance name (required)
   * @param path Template (required)
   * @param body Replace content of a template (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> putInstancesByNameMetadataTemplatesWithHttpInfo(String name, String path, File body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putInstancesByNameMetadataTemplatesRequestBuilder(name, path, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putInstancesByNameMetadataTemplates", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder putInstancesByNameMetadataTemplatesRequestBuilder(String name, String path, File body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling putInstancesByNameMetadataTemplates");
    }
    // verify the required parameter 'path' is set
    if (path == null) {
      throw new ApiException(400, "Missing the required parameter 'path' when calling putInstancesByNameMetadataTemplates");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/metadata/templates"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("path", path));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Update the snapshot
   * @param name Instance name (required)
   * @param snapshotName Snapshot name (required)
   * @param body Update the snapshot (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> putInstancesByNameSnapshotsInformation(String name, String snapshotName, UpdateInstancesByNameSnapshotsInformationRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putInstancesByNameSnapshotsInformationRequestBuilder(name, snapshotName, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putInstancesByNameSnapshotsInformation", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Update the snapshot
   * @param name Instance name (required)
   * @param snapshotName Snapshot name (required)
   * @param body Update the snapshot (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> putInstancesByNameSnapshotsInformationWithHttpInfo(String name, String snapshotName, UpdateInstancesByNameSnapshotsInformationRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putInstancesByNameSnapshotsInformationRequestBuilder(name, snapshotName, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putInstancesByNameSnapshotsInformation", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder putInstancesByNameSnapshotsInformationRequestBuilder(String name, String snapshotName, UpdateInstancesByNameSnapshotsInformationRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling putInstancesByNameSnapshotsInformation");
    }
    // verify the required parameter 'snapshotName' is set
    if (snapshotName == null) {
      throw new ApiException(400, "Missing the required parameter 'snapshotName' when calling putInstancesByNameSnapshotsInformation");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/snapshots/{snapshotName}"
        .replace("{name}", ApiClient.urlEncode(name.toString()))
        .replace("{snapshotName}", ApiClient.urlEncode(snapshotName.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * 
   * Change the instance state
   * @param name Instance name (required)
   * @param body Change the instance state (optional)
   * @return CompletableFuture&lt;BackgroundOperationResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<BackgroundOperationResponse> putInstancesByNameState(String name, UpdateInstancesByNameStateRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putInstancesByNameStateRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putInstancesByNameState", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * 
   * Change the instance state
   * @param name Instance name (required)
   * @param body Change the instance state (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;BackgroundOperationResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<BackgroundOperationResponse>> putInstancesByNameStateWithHttpInfo(String name, UpdateInstancesByNameStateRequest body) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = putInstancesByNameStateRequestBuilder(name, body);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("putInstancesByNameState", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<BackgroundOperationResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<BackgroundOperationResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder putInstancesByNameStateRequestBuilder(String name, UpdateInstancesByNameStateRequest body) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling putInstancesByNameState");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/1.0/instances/{name}/state"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
